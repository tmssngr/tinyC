@printString:
 Local variables
	arg 0: str (u8*/8)
	var 1: chr (u8/1)
	var 2: t.2 (bool/1)
	var 3: t.3 (u8/1)
	; 23 pc
	; 2:2 while true
@while_1:
	load chr, [str]
	; 4:3 if chr == 0
	const t.3, 0
	equals t.2, chr, t.3
	branch t.2, false, @if_2_end
	jump @while_1_break
@if_2_end:
	call _, printChar [chr]
	jump @while_1
@while_1_break:
@printString_ret:

@printStringLength:
 Local variables
	arg 0: str (u8*/8)
	arg 1: length (u8/1)
	var 2: chr (u8/1)
	var 3: t.3 (bool/1)
	var 4: t.4 (u8/1)
	var 5: t.5 (u8/1)
	; 31 pc
	; 13:2 while length > 0
@while_3:
	const t.4, 0
	gt t.3, length, t.4
	branch t.3, false, @while_3_break
	load chr, [str]
	call _, printChar [chr]
	const t.5, 1
	sub length, length, t.5
	jump @while_3
@while_3_break:
@printStringLength_ret:

@printUint:
 Local variables
	arg 0: number (i16/2)
	var 1: buffer[] (u8*/20)
	var 2: pos (u8/1)
	var 3: remainder (i64/8)
	var 4: digit (u8/1)
	var 5: t.5 (u8/1)
	var 6: t.6 (i16/2)
	var 7: t.7 (i16/2)
	var 8: t.8 (i16/2)
	var 9: t.9 (u8/1)
	var 10: t.10 (u8/1)
	var 11: t.11 (u8*/8)
	var 12: t.12 (i16/2)
	var 13: t.13 (u8*/8)
	var 14: t.14 (bool/1)
	var 15: t.15 (i16/2)
	var 16: t.16 (u8*/8)
	var 17: t.17 (i16/2)
	var 18: t.18 (u8*/8)
	var 19: t.19 (u8/1)
	var 20: t.20 (u8/1)
	; 137 pc
	const pos, 20
	; 24:2 while true
@while_4:
	const t.5, 1
	sub pos, pos, t.5
	const t.7, 10
	move t.6, number
	mod t.6, t.6, t.7
	cast remainder(i64), t.6(i16)
	const t.8, 10
	div number, number, t.8
	cast t.9(u8), remainder(i64)
	const t.10, 48
	move digit, t.9
	add digit, digit, t.10
	cast t.12(i16), pos(u8)
	cast t.13(u8*), t.12(i16)
	addrof t.11, [buffer]
	add t.11, t.11, t.13
	store [t.11], digit
	; 30:3 if number == 0
	const t.15, 0
	equals t.14, number, t.15
	branch t.14, false, @if_5_end
	jump @while_4_break
@if_5_end:
	jump @while_4
@while_4_break:
	cast t.17(i16), pos(u8)
	cast t.18(u8*), t.17(i16)
	addrof t.16, [buffer]
	add t.16, t.16, t.18
	const t.20, 20
	move t.19, t.20
	sub t.19, t.19, pos
	call _, printStringLength [t.16, t.19]
@printUint_ret:

@getChar:
 Local variables
	var 0: t.0 (u8/1)
	; 6 pc
	; 57:9 return 0
	const t.0, 0
	ret t.0
	jump @getChar_ret
@getChar_ret:

@setCursor:
 Local variables
	arg 0: x (u8/1)
	arg 1: y (u8/1)
	; 0 pc
@setCursor_ret:

@initRandom:
 Local variables
	arg 0: salt (i32/4)
	; 0 pc
@initRandom_ret:

@random:
 Local variables
	var 0: t.0 (i32/4)
	; 6 pc
	; 70:9 return 0
	const t.0, 0
	ret t.0
	jump @random_ret
@random_ret:

@rowColumnToCell:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	var 2: t.2 (i16/2)
	var 3: t.3 (i16/2)
	var 4: t.4 (i16/2)
	; 30 pc
	; 15:21 return row * 40 + column
	const t.4, 40
	move t.3, row
	mul t.3, t.3, t.4
	move t.2, t.3
	add t.2, t.2, column
	ret t.2
	jump @rowColumnToCell_ret
@rowColumnToCell_ret:

@getCell:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	var 2: t.2 (u8/1)
	var 3: t.3 (u8*/8)
	var 4: t.4 (i16/2)
	var 5: t.5 (u8*/8)
	; 32 pc
	; 19:15 return [...]
	call t.4, rowColumnToCell, [row, column]
	cast t.5(u8*), t.4(i16)
	addrof t.3, [field]
	add t.3, t.3, t.5
	load t.2, [t.3]
	ret t.2
	jump @getCell_ret
@getCell_ret:

@isBomb:
 Local variables
	arg 0: cell (u8/1)
	var 1: t.1 (bool/1)
	var 2: t.2 (u8/1)
	var 3: t.3 (u8/1)
	var 4: t.4 (u8/1)
	; 27 pc
	; 23:27 return cell & 1 != 0
	const t.3, 1
	move t.2, cell
	and t.2, t.2, t.3
	const t.4, 0
	notequals t.1, t.2, t.4
	ret t.1
	jump @isBomb_ret
@isBomb_ret:

@isOpen:
 Local variables
	arg 0: cell (u8/1)
	var 1: t.1 (bool/1)
	var 2: t.2 (u8/1)
	var 3: t.3 (u8/1)
	var 4: t.4 (u8/1)
	; 27 pc
	; 27:27 return cell & 2 != 0
	const t.3, 2
	move t.2, cell
	and t.2, t.2, t.3
	const t.4, 0
	notequals t.1, t.2, t.4
	ret t.1
	jump @isOpen_ret
@isOpen_ret:

@isFlag:
 Local variables
	arg 0: cell (u8/1)
	var 1: t.1 (bool/1)
	var 2: t.2 (u8/1)
	var 3: t.3 (u8/1)
	var 4: t.4 (u8/1)
	; 27 pc
	; 31:27 return cell & 4 != 0
	const t.3, 4
	move t.2, cell
	and t.2, t.2, t.3
	const t.4, 0
	notequals t.1, t.2, t.4
	ret t.1
	jump @isFlag_ret
@isFlag_ret:

@checkCellBounds:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	var 2: t.2 (bool/1)
	var 3: t.3 (i16/2)
	var 4: t.4 (i16/2)
	var 5: t.5 (i16/2)
	var 6: t.6 (i16/2)
	; 49 pc
	; 36:21 return row >= 0 && row < 20 && column >= 0 && column < 40
	; 36:21 logic and
	; 36:6 logic and
	; 35:21 logic and
	const t.3, 0
	gteq t.2, row, t.3
	branch t.2, false, @and_next_8
	const t.4, 20
	lt t.2, row, t.4
@and_next_8:
	branch t.2, false, @and_next_7
	const t.5, 0
	gteq t.2, column, t.5
@and_next_7:
	branch t.2, false, @and_next_6
	const t.6, 40
	lt t.2, column, t.6
@and_next_6:
	ret t.2
	jump @checkCellBounds_ret
@checkCellBounds_ret:

@setCell:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	arg 2: cell (u8/1)
	var 3: t.3 (u8*/8)
	var 4: t.4 (i16/2)
	var 5: t.5 (u8*/8)
	; 28 pc
	call t.4, rowColumnToCell, [row, column]
	cast t.5(u8*), t.4(i16)
	addrof t.3, [field]
	add t.3, t.3, t.5
	store [t.3], cell
@setCell_ret:

@getBombCountAround:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	var 2: count (u8/1)
	var 3: dr (i16/2)
	var 4: r (i16/2)
	var 5: dc (i16/2)
	var 6: c (i16/2)
	var 7: cell (u8/1)
	var 8: t.8 (bool/1)
	var 9: t.9 (i16/2)
	var 10: t.10 (bool/1)
	var 11: t.11 (i16/2)
	var 12: t.12 (bool/1)
	var 13: t.13 (bool/1)
	var 14: t.14 (u8/1)
	var 15: t.15 (i16/2)
	var 16: t.16 (i16/2)
	; 112 pc
	const count, 0
	const dr, -1
	; 45:2 for dr <= 1
@for_9:
	const t.9, 1
	lteq t.8, dr, t.9
	branch t.8, false, @for_9_break
	move r, row
	add r, r, dr
	const dc, -1
	; 47:3 for dc <= 1
@for_10:
	const t.11, 1
	lteq t.10, dc, t.11
	branch t.10, false, @for_10_break
	move c, column
	add c, c, dc
	; 49:4 if checkCellBounds([ExprVarAccess[varName=r, index=4, scope=function, type=i16, varIsArray=false, location=49:24], ExprVarAccess[varName=c, index=6, scope=function, type=i16, varIsArray=false, location=49:27]])
	call t.12, checkCellBounds, [r, c]
	branch t.12, false, @if_11_end
	call cell, getCell, [r, c]
	; 51:5 if isBomb([ExprVarAccess[varName=cell, index=7, scope=function, type=u8, varIsArray=false, location=51:16]])
	call t.13, isBomb, [cell]
	branch t.13, false, @if_12_end
	const t.14, 1
	add count, count, t.14
@if_12_end:
@if_11_end:
@for_10_continue:
	const t.15, 1
	add dc, dc, t.15
	jump @for_10
@for_10_break:
@for_9_continue:
	const t.16, 1
	add dr, dr, t.16
	jump @for_9
@for_9_break:
	; 57:9 return count
	ret count
	jump @getBombCountAround_ret
@getBombCountAround_ret:

@getSpacer:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	arg 2: rowCursor (i16/2)
	arg 3: columnCursor (i16/2)
	var 4: t.4 (bool/1)
	var 5: t.5 (bool/1)
	var 6: t.6 (u8/1)
	var 7: t.7 (bool/1)
	var 8: t.8 (i16/2)
	var 9: t.9 (i16/2)
	var 10: t.10 (u8/1)
	var 11: t.11 (u8/1)
	; 62 pc
	; 61:2 if rowCursor == row
	equals t.4, rowCursor, row
	branch t.4, false, @if_13_end
	; 62:3 if columnCursor == column
	equals t.5, columnCursor, column
	branch t.5, false, @if_14_end
	; 63:11 return 91
	const t.6, 91
	ret t.6
	jump @getSpacer_ret
@if_14_end:
	; 65:3 if columnCursor == column - 1
	const t.9, 1
	move t.8, column
	sub t.8, t.8, t.9
	equals t.7, columnCursor, t.8
	branch t.7, false, @if_15_end
	; 66:11 return 93
	const t.10, 93
	ret t.10
	jump @getSpacer_ret
@if_15_end:
@if_13_end:
	; 69:9 return 32
	const t.11, 32
	ret t.11
	jump @getSpacer_ret
@getSpacer_ret:

@printCell:
 Local variables
	arg 0: cell (u8/1)
	arg 1: row (i16/2)
	arg 2: column (i16/2)
	var 3: chr (u8/1)
	var 4: count (u8/1)
	var 5: t.5 (bool/1)
	var 6: t.6 (bool/1)
	var 7: t.7 (bool/1)
	var 8: t.8 (u8/1)
	var 9: t.9 (u8/1)
	var 10: t.10 (bool/1)
	; 71 pc
	const chr, 46
	; 74:2 if isOpen([ExprVarAccess[varName=cell, index=0, scope=argument, type=u8, varIsArray=false, location=74:13]])
	call t.5, isOpen, [cell]
	branch t.5, false, @if_16_else
	; 75:3 if isBomb([ExprVarAccess[varName=cell, index=0, scope=argument, type=u8, varIsArray=false, location=75:14]])
	call t.6, isBomb, [cell]
	branch t.6, false, @if_17_else
	const chr, 42
	jump @if_17_end
@if_17_else:
	call count, getBombCountAround, [row, column]
	; 80:4 if count > 0
	const t.8, 0
	gt t.7, count, t.8
	branch t.7, false, @if_18_else
	const t.9, 48
	move chr, count
	add chr, chr, t.9
	jump @if_18_end
@if_18_else:
	const chr, 32
@if_18_end:
@if_17_end:
	jump @if_16_end
@if_16_else:
	; 88:7 if isFlag([ExprVarAccess[varName=cell, index=0, scope=argument, type=u8, varIsArray=false, location=88:18]])
	call t.10, isFlag, [cell]
	branch t.10, false, @if_19_end
	const chr, 35
@if_19_end:
@if_16_end:
	call _, printChar [chr]
@printCell_ret:

@printField:
 Local variables
	arg 0: rowCursor (i16/2)
	arg 1: columnCursor (i16/2)
	var 2: row (i16/2)
	var 3: column (i16/2)
	var 4: spacer (u8/1)
	var 5: cell (u8/1)
	var 6: spacer (u8/1)
	var 7: t.7 (u8/1)
	var 8: t.8 (u8/1)
	var 9: t.9 (bool/1)
	var 10: t.10 (i16/2)
	var 11: t.11 (u8/1)
	var 12: t.12 (bool/1)
	var 13: t.13 (i16/2)
	var 14: t.14 (i16/2)
	var 15: t.15 (i16/2)
	var 16: t.16 (u8*/8)
	var 17: t.17 (i16/2)
	; 112 pc
	const t.7, 0
	const t.8, 0
	call _, setCursor [t.7, t.8]
	const row, 0
	; 96:2 for row < 20
@for_20:
	const t.10, 20
	lt t.9, row, t.10
	branch t.9, false, @for_20_break
	const t.11, 124
	call _, printChar [t.11]
	const column, 0
	; 98:3 for column < 40
@for_21:
	const t.13, 40
	lt t.12, column, t.13
	branch t.12, false, @for_21_break
	call spacer, getSpacer, [row, column, rowCursor, columnCursor]
	call _, printChar [spacer]
	call cell, getCell, [row, column]
	call _, printCell [cell, row, column]
@for_21_continue:
	const t.14, 1
	add column, column, t.14
	jump @for_21
@for_21_break:
	const t.15, 40
	call spacer, getSpacer, [row, t.15, rowCursor, columnCursor]
	call _, printChar [spacer]
	const t.16, [string-0]
	call _, printString [t.16]
@for_20_continue:
	const t.17, 1
	add row, row, t.17
	jump @for_20
@for_20_break:
@printField_ret:

@printSpaces:
 Local variables
	arg 0: i (i16/2)
	var 1: t.1 (bool/1)
	var 2: t.2 (i16/2)
	var 3: t.3 (u8/1)
	var 4: t.4 (i16/2)
	; 27 pc
	; 111:2 for i > 0
@for_22:
	const t.2, 0
	gt t.1, i, t.2
	branch t.1, false, @for_22_break
	const t.3, 48
	call _, printChar [t.3]
@for_22_continue:
	const t.4, 1
	sub i, i, t.4
	jump @for_22
@for_22_break:
@printSpaces_ret:

@getDigitCount:
 Local variables
	arg 0: value (i16/2)
	var 1: count (u8/1)
	var 2: t.2 (bool/1)
	var 3: t.3 (i16/2)
	var 4: t.4 (u8/1)
	var 5: t.5 (i16/2)
	var 6: t.6 (bool/1)
	var 7: t.7 (i16/2)
	; 57 pc
	const count, 0
	; 118:2 if value < 0
	const t.3, 0
	lt t.2, value, t.3
	branch t.2, false, @if_23_end
	const count, 1
	neg value, value
@if_23_end:
	; 123:2 while true
@while_24:
	const t.4, 1
	add count, count, t.4
	const t.5, 10
	div value, value, t.5
	; 126:3 if value == 0
	const t.7, 0
	equals t.6, value, t.7
	branch t.6, false, @if_25_end
	jump @while_24_break
@if_25_end:
	jump @while_24
@while_24_break:
	; 131:9 return count
	ret count
	jump @getDigitCount_ret
@getDigitCount_ret:

@getHiddenCount:
 Local variables
	var 0: count (i16/2)
	var 1: r (i16/2)
	var 2: c (i16/2)
	var 3: cell (u8/1)
	var 4: t.4 (bool/1)
	var 5: t.5 (i16/2)
	var 6: t.6 (bool/1)
	var 7: t.7 (i16/2)
	var 8: t.8 (bool/1)
	var 9: t.9 (u8/1)
	var 10: t.10 (u8/1)
	var 11: t.11 (u8/1)
	var 12: t.12 (i16/2)
	var 13: t.13 (i16/2)
	var 14: t.14 (i16/2)
	; 96 pc
	const count, 0
	const r, 0
	; 136:2 for r < 20
@for_26:
	const t.5, 20
	lt t.4, r, t.5
	branch t.4, false, @for_26_break
	const c, 0
	; 137:3 for c < 40
@for_27:
	const t.7, 40
	lt t.6, c, t.7
	branch t.6, false, @for_27_break
	call cell, getCell, [r, c]
	; 139:4 if cell & 6 == 0
	const t.10, 6
	move t.9, cell
	and t.9, t.9, t.10
	const t.11, 0
	equals t.8, t.9, t.11
	branch t.8, false, @if_28_end
	const t.12, 1
	add count, count, t.12
@if_28_end:
@for_27_continue:
	const t.13, 1
	add c, c, t.13
	jump @for_27
@for_27_break:
@for_26_continue:
	const t.14, 1
	add r, r, t.14
	jump @for_26
@for_26_break:
	; 144:9 return count
	ret count
	jump @getHiddenCount_ret
@getHiddenCount_ret:

@printLeft:
 Local variables
	var 0: count (i16/2)
	var 1: leftDigits (i16/2)
	var 2: bombDigits (i16/2)
	var 3: t.3 (u8/1)
	var 4: t.4 (u8/1)
	var 5: t.5 (i16/2)
	var 6: t.6 (u8*/8)
	var 7: t.7 (i16/2)
	var 8: t.8 (bool/1)
	var 9: t.9 (i16/2)
	; 62 pc
	call count, getHiddenCount, []
	call t.3, getDigitCount, [count]
	cast leftDigits(i16), t.3(u8)
	const t.5, 40
	call t.4, getDigitCount, [t.5]
	cast bombDigits(i16), t.4(u8)
	const t.6, [string-1]
	call _, printString [t.6]
	move t.7, bombDigits
	sub t.7, t.7, leftDigits
	call _, printSpaces [t.7]
	call _, printUint [count]
	; 155:15 return count == 0
	const t.9, 0
	equals t.8, count, t.9
	ret t.8
	jump @printLeft_ret
@printLeft_ret:

@abs:
 Local variables
	arg 0: a (i16/2)
	var 1: t.1 (bool/1)
	var 2: t.2 (i16/2)
	var 3: t.3 (i16/2)
	; 25 pc
	; 159:2 if a < 0
	const t.2, 0
	lt t.1, a, t.2
	branch t.1, false, @if_29_end
	; 160:10 return -a
	neg t.3, a
	ret t.3
	jump @abs_ret
@if_29_end:
	; 162:9 return a
	ret a
	jump @abs_ret
@abs_ret:

@clearField:
 Local variables
	var 0: r (i16/2)
	var 1: c (i16/2)
	var 2: t.2 (bool/1)
	var 3: t.3 (i16/2)
	var 4: t.4 (bool/1)
	var 5: t.5 (i16/2)
	var 6: t.6 (u8/1)
	var 7: t.7 (i16/2)
	var 8: t.8 (i16/2)
	; 57 pc
	const r, 0
	; 166:2 for r < 20
@for_30:
	const t.3, 20
	lt t.2, r, t.3
	branch t.2, false, @for_30_break
	const c, 0
	; 167:3 for c < 40
@for_31:
	const t.5, 40
	lt t.4, c, t.5
	branch t.4, false, @for_31_break
	const t.6, 0
	call _, setCell [r, c, t.6]
@for_31_continue:
	const t.7, 1
	add c, c, t.7
	jump @for_31
@for_31_break:
@for_30_continue:
	const t.8, 1
	add r, r, t.8
	jump @for_30
@for_30_break:
@clearField_ret:

@initField:
 Local variables
	arg 0: curr_r (i16/2)
	arg 1: curr_c (i16/2)
	var 2: bombs (i16/2)
	var 3: row (i16/2)
	var 4: column (i16/2)
	var 5: t.5 (bool/1)
	var 6: t.6 (i16/2)
	var 7: t.7 (i32/4)
	var 8: t.8 (i32/4)
	var 9: t.9 (i32/4)
	var 10: t.10 (i32/4)
	var 11: t.11 (i32/4)
	var 12: t.12 (i32/4)
	var 13: t.13 (bool/1)
	var 14: t.14 (i16/2)
	var 15: t.15 (i16/2)
	var 16: t.16 (i16/2)
	var 17: t.17 (i16/2)
	var 18: t.18 (i16/2)
	var 19: t.19 (i16/2)
	var 20: t.20 (u8/1)
	var 21: t.21 (i16/2)
	; 135 pc
	const bombs, 40
	; 174:2 for bombs > 0
@for_32:
	const t.6, 0
	gt t.5, bombs, t.6
	branch t.5, false, @for_32_break
	call t.8, random, []
	const t.9, 20
	move t.7, t.8
	mod t.7, t.7, t.9
	cast row(i16), t.7(i32)
	call t.11, random, []
	const t.12, 40
	move t.10, t.11
	mod t.10, t.10, t.12
	cast column(i16), t.10(i32)
	; 177:3 if abs([ExprBinary[op=-, type=i16, left=ExprVarAccess[varName=row, index=3, scope=function, type=i16, varIsArray=false, location=177:11], right=ExprVarAccess[varName=curr_r, index=0, scope=argument, type=i16, varIsArray=false, location=177:20], location=177:18]]) > 1 || abs([ExprBinary[op=-, type=i16, left=ExprVarAccess[varName=column, index=4, scope=function, type=i16, varIsArray=false, location=178:11], right=ExprVarAccess[varName=curr_c, index=1, scope=argument, type=i16, varIsArray=false, location=178:20], location=178:18]]) > 1
	; 178:4 logic or
	move t.15, row
	sub t.15, t.15, curr_r
	call t.14, abs, [t.15]
	const t.16, 1
	gt t.13, t.14, t.16
	branch t.13, true, @or_next_34
	move t.18, column
	sub t.18, t.18, curr_c
	call t.17, abs, [t.18]
	const t.19, 1
	gt t.13, t.17, t.19
@or_next_34:
	branch t.13, false, @if_33_end
	const t.20, 1
	call _, setCell [row, column, t.20]
@if_33_end:
@for_32_continue:
	const t.21, 1
	sub bombs, bombs, t.21
	jump @for_32
@for_32_break:
@initField_ret:

@maybeRevealAround:
 Local variables
	arg 0: row (i16/2)
	arg 1: column (i16/2)
	var 2: dr (i16/2)
	var 3: r (i16/2)
	var 4: dc (i16/2)
	var 5: c (i16/2)
	var 6: cell (u8/1)
	var 7: t.7 (bool/1)
	var 8: t.8 (u8/1)
	var 9: t.9 (u8/1)
	var 10: t.10 (bool/1)
	var 11: t.11 (i16/2)
	var 12: t.12 (bool/1)
	var 13: t.13 (i16/2)
	var 14: t.14 (bool/1)
	var 15: t.15 (i16/2)
	var 16: t.16 (i16/2)
	var 17: t.17 (bool/1)
	var 18: t.18 (bool/1)
	var 19: t.19 (bool/1)
	var 20: t.20 (u8/1)
	var 21: t.21 (u8/1)
	var 22: t.22 (i16/2)
	var 23: t.23 (i16/2)
	; 175 pc
	; 185:2 if getBombCountAround([ExprVarAccess[varName=row, index=0, scope=argument, type=i16, varIsArray=false, location=185:25], ExprVarAccess[varName=column, index=1, scope=argument, type=i16, varIsArray=false, location=185:30]]) != 0
	call t.8, getBombCountAround, [row, column]
	const t.9, 0
	notequals t.7, t.8, t.9
	branch t.7, false, @if_35_end
	; 186:3 return
	jump @maybeRevealAround_ret
@if_35_end:
	const dr, -1
	; 189:2 for dr <= 1
@for_36:
	const t.11, 1
	lteq t.10, dr, t.11
	branch t.10, false, @for_36_break
	move r, row
	add r, r, dr
	const dc, -1
	; 191:3 for dc <= 1
@for_37:
	const t.13, 1
	lteq t.12, dc, t.13
	branch t.12, false, @for_37_break
	; 192:4 if dr == 0 && dc == 0
	; 192:16 logic and
	const t.15, 0
	equals t.14, dr, t.15
	branch t.14, false, @and_next_39
	const t.16, 0
	equals t.14, dc, t.16
@and_next_39:
	branch t.14, false, @if_38_end
	jump @for_37_continue
@if_38_end:
	move c, column
	add c, c, dc
	; 197:4 if !checkCellBounds([ExprVarAccess[varName=r, index=3, scope=function, type=i16, varIsArray=false, location=197:25], ExprVarAccess[varName=c, index=5, scope=function, type=i16, varIsArray=false, location=197:28]])
	call t.18, checkCellBounds, [r, c]
	notlog t.17, t.18
	branch t.17, false, @if_40_end
	jump @for_37_continue
@if_40_end:
	call cell, getCell, [r, c]
	; 202:4 if isOpen([ExprVarAccess[varName=cell, index=6, scope=function, type=u8, varIsArray=false, location=202:15]])
	call t.19, isOpen, [cell]
	branch t.19, false, @if_41_end
	jump @for_37_continue
@if_41_end:
	const t.21, 2
	move t.20, cell
	or t.20, t.20, t.21
	call _, setCell [r, c, t.20]
	call _, maybeRevealAround [r, c]
@for_37_continue:
	const t.22, 1
	add dc, dc, t.22
	jump @for_37
@for_37_break:
@for_36_continue:
	const t.23, 1
	add dr, dr, t.23
	jump @for_36
@for_36_break:
@maybeRevealAround_ret:

@main:
 Local variables
	var 0: needsInitialize (bool/1)
	var 1: curr_c (i16/2)
	var 2: curr_r (i16/2)
	var 3: chr (i16/2)
	var 4: cell (u8/1)
	var 5: cell (u8/1)
	var 6: t.6 (i32/4)
	var 7: t.7 (u8/1)
	var 8: t.8 (u8/1)
	var 9: t.9 (bool/1)
	var 10: t.10 (bool/1)
	var 11: t.11 (u8*/8)
	var 12: t.12 (u8/1)
	var 13: t.13 (bool/1)
	var 14: t.14 (i16/2)
	var 15: t.15 (bool/1)
	var 16: t.16 (i16/2)
	var 17: t.17 (i16/2)
	var 18: t.18 (i16/2)
	var 19: t.19 (i16/2)
	var 20: t.20 (i16/2)
	var 21: t.21 (i16/2)
	var 22: t.22 (bool/1)
	var 23: t.23 (i16/2)
	var 24: t.24 (i16/2)
	var 25: t.25 (i16/2)
	var 26: t.26 (i16/2)
	var 27: t.27 (bool/1)
	var 28: t.28 (i16/2)
	var 29: t.29 (i16/2)
	var 30: t.30 (i16/2)
	var 31: t.31 (i16/2)
	var 32: t.32 (i16/2)
	var 33: t.33 (i16/2)
	var 34: t.34 (bool/1)
	var 35: t.35 (i16/2)
	var 36: t.36 (i16/2)
	var 37: t.37 (i16/2)
	var 38: t.38 (i16/2)
	var 39: t.39 (i16/2)
	var 40: t.40 (i16/2)
	var 41: t.41 (bool/1)
	var 42: t.42 (i16/2)
	var 43: t.43 (i16/2)
	var 44: t.44 (i16/2)
	var 45: t.45 (i16/2)
	var 46: t.46 (bool/1)
	var 47: t.47 (i16/2)
	var 48: t.48 (bool/1)
	var 49: t.49 (bool/1)
	var 50: t.50 (bool/1)
	var 51: t.51 (u8/1)
	var 52: t.52 (bool/1)
	var 53: t.53 (i16/2)
	var 54: t.54 (bool/1)
	var 55: t.55 (bool/1)
	var 56: t.56 (u8/1)
	var 57: t.57 (u8/1)
	var 58: t.58 (bool/1)
	var 59: t.59 (u8*/8)
	; 462 pc
	; begin initialize global variables
	; end initialize global variables
	const t.6, 7439742
	call _, initRandom [t.6]
	const needsInitialize, 1
	call _, clearField []
	const t.7, 20
	cast curr_c(i16), t.7(u8)
	const t.8, 10
	cast curr_r(i16), t.8(u8)
	; 218:2 while true
@while_42:
	call _, printField [curr_r, curr_c]
	; 220:3 if !needsInitialize
	notlog t.9, needsInitialize
	branch t.9, false, @if_43_end
	; 221:4 if printLeft([])
	call t.10, printLeft, []
	branch t.10, false, @if_44_end
	const t.11, [string-2]
	call _, printString [t.11]
	jump @while_42_break
@if_44_end:
@if_43_end:
	call t.12, getChar, []
	cast chr(i16), t.12(u8)
	; 228:3 if chr == 27
	const t.14, 27
	equals t.13, chr, t.14
	branch t.13, false, @if_45_end
	jump @while_42_break
@if_45_end:
	; 233:3 if chr == 57416
	const t.16, 57416
	equals t.15, chr, t.16
	branch t.15, false, @if_46_else
	const t.19, 20
	move t.18, curr_r
	add t.18, t.18, t.19
	const t.20, 1
	move t.17, t.18
	sub t.17, t.17, t.20
	const t.21, 20
	move curr_r, t.17
	mod curr_r, curr_r, t.21
	jump @if_46_end
@if_46_else:
	; 237:8 if chr == 57424
	const t.23, 57424
	equals t.22, chr, t.23
	branch t.22, false, @if_47_else
	const t.25, 1
	move t.24, curr_r
	add t.24, t.24, t.25
	const t.26, 20
	move curr_r, t.24
	mod curr_r, curr_r, t.26
	jump @if_47_end
@if_47_else:
	; 241:8 if chr == 57419
	const t.28, 57419
	equals t.27, chr, t.28
	branch t.27, false, @if_48_else
	const t.31, 40
	move t.30, curr_c
	add t.30, t.30, t.31
	const t.32, 1
	move t.29, t.30
	sub t.29, t.29, t.32
	const t.33, 40
	move curr_c, t.29
	mod curr_c, curr_c, t.33
	jump @if_48_end
@if_48_else:
	; 245:8 if chr == 57419
	const t.35, 57419
	equals t.34, chr, t.35
	branch t.34, false, @if_49_else
	const t.38, 40
	move t.37, curr_c
	add t.37, t.37, t.38
	const t.39, 1
	move t.36, t.37
	sub t.36, t.36, t.39
	const t.40, 40
	move curr_c, t.36
	mod curr_c, curr_c, t.40
	jump @if_49_end
@if_49_else:
	; 249:8 if chr == 57421
	const t.42, 57421
	equals t.41, chr, t.42
	branch t.41, false, @if_50_else
	const t.44, 1
	move t.43, curr_c
	add t.43, t.43, t.44
	const t.45, 40
	move curr_c, t.43
	mod curr_c, curr_c, t.45
	jump @if_50_end
@if_50_else:
	; 253:8 if chr == 32
	const t.47, 32
	equals t.46, chr, t.47
	branch t.46, false, @if_51_else
	; 254:4 if !needsInitialize
	notlog t.48, needsInitialize
	branch t.48, false, @if_52_end
	call cell, getCell, [curr_r, curr_c]
	; 256:5 if !isOpen([ExprVarAccess[varName=cell, index=4, scope=function, type=u8, varIsArray=false, location=256:17]])
	call t.50, isOpen, [cell]
	notlog t.49, t.50
	branch t.49, false, @if_53_end
	const t.51, 4
	xor cell, cell, t.51
	call _, setCell [curr_r, curr_c, cell]
@if_53_end:
@if_52_end:
	jump @if_51_end
@if_51_else:
	; 262:8 if chr == 13
	const t.53, 13
	equals t.52, chr, t.53
	branch t.52, false, @if_54_end
	; 263:4 if needsInitialize
	branch needsInitialize, false, @if_55_end
	const needsInitialize, 0
	call _, initField [curr_r, curr_c]
@if_55_end:
	call cell, getCell, [curr_r, curr_c]
	; 268:4 if !isOpen([ExprVarAccess[varName=cell, index=5, scope=function, type=u8, varIsArray=false, location=268:16]])
	call t.55, isOpen, [cell]
	notlog t.54, t.55
	branch t.54, false, @if_56_end
	const t.57, 2
	move t.56, cell
	or t.56, t.56, t.57
	call _, setCell [curr_r, curr_c, t.56]
@if_56_end:
	; 271:4 if isBomb([ExprVarAccess[varName=cell, index=5, scope=function, type=u8, varIsArray=false, location=271:15]])
	call t.58, isBomb, [cell]
	branch t.58, false, @if_57_end
	call _, printField [curr_r, curr_c]
	const t.59, [string-3]
	call _, printString [t.59]
	jump @while_42_break
@if_57_end:
	call _, maybeRevealAround [curr_r, curr_c]
@if_54_end:
@if_51_end:
@if_50_end:
@if_49_end:
@if_48_end:
@if_47_end:
@if_46_end:
	jump @while_42
@while_42_break:
@main_ret:

@printChar:
	ld   r0, SPH
	ld   r1, SPL
	add  r1, 3
	adc  r0, 0
	ldc  r1, @rr0
	ld   %15, r1
	jp   %0818

Global variables
	0: field[] (u8*/6400)

String literals
	string lit 0 "|\n\0"
	string lit 1 "Left: \0"
	string lit 2 " You've cleaned the field!\0"
	string lit 3 "boom! you've lost\0"
